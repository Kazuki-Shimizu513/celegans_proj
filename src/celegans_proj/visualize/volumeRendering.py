# -*- coding: utf-8 -*-
"""volumeRendering(RayCasting).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1630PmPhVxXgSenp_AZJUiUPaj9-f-iC7
"""

# !pip install -U   plotly  kaleido

import numpy as np
import torch

import json
from pathlib import Path, PurePath
import shutil

import tifffile
from skimage import io

import plotly
import plotly.express as px
import plotly.graph_objects as go

def resize_volume(volume, size=(64,128,128), debug_flag = False):

    if debug_flag:
        print("\n In resize volume func")
        print(f"{volume.shape=}\t{type(volume)=}")
        # volume.shape=(68, 189, 157)	type(volume)=<class 'numpy.ndarray'>

    volume = torch.from_numpy(volume)
    volume = torch.unsqueeze(volume, 0)
    volume = torch.unsqueeze(volume, 0)

    if debug_flag:
        print(f"{volume.shape=}\t{type(volume)=}")

    down = torch.nn.Upsample(size=size)
    volume = down(volume)

    if debug_flag:
        print(f'down vol shape ={volume.shape} ',)

    volume = torch.squeeze(volume, 0)
    volume = torch.squeeze(volume, 0)
    volume = volume.to('cpu').detach().numpy().copy()

    if debug_flag:
        print(f"{volume.shape=}\t{type(volume)=}")
        print("end resize volume func \n\n")

    return volume


def min_max(x, axis=None):
    tmp_min = x.min(axis=axis, keepdims=True)
    tmp_max = x.max(axis=axis, keepdims=True)
    result = (x-tmp_min)/(tmp_max-tmp_min)
    return result

def gamma_correction(
    img,
    g = 2.2,
    c = 1.,
    ):
    # Gammma correction

    out = img.copy()
    # out = out.astype(np.uint8)
    # out /= 255.
    out = (1/c * out) ** (1/g)

    # out *= 255
    # out = out.astype(np.uint8)
    return out

def LoG_filter(gray,
              K_size = 5,  # Gaussian Filter
              s = 3, # Laplacian
    ):
    # LoGフィルタとはLaplacian of Gaussianであり、
    # ガウシアンフィルタで画像を平滑化した後に
    # ラプラシアンフィルタで輪郭を取り出すフィルタである。
    #  Laplcianフィルタは二次微分をとるので
    #  ノイズが強調されるのを防ぐために、
    # 予めGaussianフィルタでノイズを抑える。

    H, W = gray.shape

    ## Zero padding
    pad = K_size // 2
    out = np.zeros((H + pad*2, W + pad*2), dtype=float)
    out[pad:pad+H, pad:pad+W] = gray.copy()
    # out = out.astype(np.float)
    tmp = out.copy()

    ## Kernel
    K = np.zeros((K_size, K_size), dtype=float)
    for x in range(-pad, -pad+K_size):
        for y in range(-pad, -pad+K_size):
            K[y+pad, x+pad] = (x**2 + y**2 - s**2) * np.exp( -(x**2 + y**2) / (2* (s**2)))
    K /= (2 * np.pi * (s**6))
    K /= K.sum()

    for y in range(H):
        for x in range(W):
            out[pad+y, pad+x] = np.sum(K * tmp[y:y+K_size, x:x+K_size])

    out = out[pad:pad+H, pad:pad+W]
    # out = out.astype(np.uint8)
    return out

def get_voxel_slider(volume):
    nb_frames, r, c  = volume.shape
    # nb_frames = 68

    fig = go.Figure(frames=[go.Frame(data=go.Surface(
        z=((nb_frames-1) - k ) * np.ones((r, c)),
        surfacecolor=np.flipud(volume[(nb_frames-1) - k]),
        # cmin=0, cmax=200
        ),
        name=str(k) # you need to name the frame for the animation to behave properly
        )
        for k in range(nb_frames)])

    # Add data to be displayed before animation starts
    fig.add_trace(go.Surface(
        z=(nb_frames-1) * np.ones((r, c)),
        surfacecolor=np.flipud(volume[(nb_frames-1)]),
        # colorscale='Gray',
        colorscale='Viridis',
        # cmin=0, cmax=200,
        # colorbar=dict(thickness=20, ticklen=4)
        ))


    def frame_args(duration):
        return {
                "frame": {"duration": duration},
                "mode": "immediate",
                "fromcurrent": True,
                "transition": {"duration": duration, "easing": "linear"},
            }

    sliders = [
                {
                    "pad": {"b": 10, "t": 60},
                    "len": 0.9,
                    "x": 0.1,
                    "y": 0,
                    "steps": [
                        {
                            "args": [[f.name], frame_args(0)],
                            "label": str(k),
                            "method": "animate",
                        }
                        for k, f in enumerate(fig.frames)
                    ],
                }
            ]

    # Layout
    fig.update_layout(
            # title='Slices in volumetric data',
            # width=600,
            # height=600,
            scene=dict(
                        zaxis=dict(range=[-1, nb_frames], autorange=False),
                        aspectratio=dict(x=1, y=1, z=1),
                        ),
            updatemenus = [
                {
                    "buttons": [
                        {
                            "args": [None, frame_args(50)],
                            "label": "&#9654;", # play symbol
                            "method": "animate",
                        },
                        {
                            "args": [[None], frame_args(0)],
                            "label": "&#9724;", # pause symbol
                            "method": "animate",
                        },
                    ],
                    "direction": "left",
                    "pad": {"r": 10, "t": 70},
                    "type": "buttons",
                    "x": 0.1,
                    "y": 0,
                }
            ],
            sliders=sliders
    )
    return fig

def get_values_and_its_coodinates(vol):
  # time comsuming
  z_len,y_len,x_len  = vol.shape
  Z = np.array([])
  Y = np.array([])
  X = np.array([])
  Values = np.array([])
  # run from (z_top, y_high, x_left) = (0,0,0)
  for z in range(z_len):
    for y in range(y_len):
      for x in range(x_len):
        Z = np.append(Z, z)
        Y = np.append(Y, y)
        X = np.append(X, x)
        Values = np.append(Values, vol[z,y,x].copy())

  return Z,Y,X, Values,

def get_values_and_its_coodinates2(vol):
    z_len,y_len,x_len  = vol.shape
    X, Y, Z = np.meshgrid(np.arange(x_len), np.arange(y_len),np.arange(z_len),)
    Values = vol.ravel().copy()
    return Z,Y,X, Values,

def get_voxel_fig(vol,
               iso_range = (0.1, 0.8),
               opacity=0.1,  # needs to be small to see through all surfaces
               surface_count=17, # needs to be a large number for good volume rendering
               debug_flag=False,
               ):
    # print(iso_range[0])
    Z, Y, X,Values, = get_values_and_its_coodinates2(vol)
    Z, Y, X, = Z.T, Y.T, X.T,
    if debug_flag:
        print(f"befor plot volume ¥n{Z.shape=}{Y.shape=}{X.shape=}{Values.shape=}{Values.min()=}{Values.max()=}")
    fig = go.Figure(data=go.Volume(
        x=X.flatten(),
        y=Y.flatten(),
        z=Z.flatten(),
        value=Values.flatten(),
        isomin=iso_range[0],
        isomax=iso_range[1],
        opacity=opacity,
        colorscale='Viridis',
        # surface_count=surface_count, # needs to be a large number for good volume rendering

        ))
    return fig

def main():


    debug_flag = True
    size=(33,64,64)

    iso_range_1 = (0.33, 0.999)
    # iso_range_2 = (0.60, 0.999)
    opacity=0.2  # needs to be small to see through all surfaces
    # surface_count=12 # needs to be a large number for good volume rendering

    gamma = 2.2
    kernelSize = 5
    laplace_size = 2


#     try:
#         from google.colab import drive
#         drive.mount('/content/drive')
#         in_dir = Path('/content/drive/MyDrive/Data/celegans/WDDD2/volume')
#         in_path = in_dir.joinpath("wt_N2_081113_01/wt_N2_081113_01_T50.npy")
#         # out_dir = Path("/content/out_test")
#         out_dir = in_dir.joinpath("out_test")
#         out_dir.mkdir(exist_ok=True,)
#         if not in_path.exists() :
#           if debug_flag:
#             print(f"{in_path.exists()=}")
#           raise Exception

#         iso_range_1 = (0.60, 0.99)
#         iso_range_2 = (0.60, 0.99)
#         opacity=0.2  # needs to be small to see through all surfaces
#         # surface_count=12 # needs to be a large number for good volume rendering
#         vol = np.load(str(in_path))

#     except Exception as err:
#         if debug_flag:
#           print(err)
#           print("use mri volume instead of c.elegans one")
#         in_path = "https://s3.amazonaws.com/assets.datacamp.com/blog_assets/attention-mri.tif"
#         out_dir = Path("/content/out_test")
#         out_dir.mkdir(exist_ok=True,)
#         iso_range_1 = (80, 255)
#         opacity=0.2  # needs to be small to see through all surfaces
#         # surface_count=12 # needs to be a large number for good volume rendering
#         vol = io.imread(in_path)

    in_dir = Path('/mnt/f/WDDD2/VOXEL/')
    # in_dir_list = [p for p in in_dir.iterdir() if p.is_dir()]
    in_path = in_dir.joinpath("wt_N2_081113_01/wt_N2_081113_01_T50.npy")
    base_out_dir = Path('/mnt/f/WDDD2/visualize/')
    out_dir = base_out_dir.joinpath("wt_N2_081113_01/T0/")
    out_dir.mkdir(exist_ok=True, parents=True)
    volume = np.load(str(in_path))

    # print(vol.shape) # (66,600,600)
    # volume = vol.T # if (600,600,66)

    volume = resize_volume(volume, size, debug_flag)


    fig = px.imshow(volume[0], color_continuous_scale=px.colors.sequential.Viridis,)
    fig.write_image(str(out_dir.joinpath("test_img.png")))
    fig.write_html(str(out_dir.joinpath("test_img.html")))
    fig.show()


    volume_1 = min_max(volume)  #(0,1)

#     # ガンマ補正
#     for idx in range(volume_1.shape[0]):
#       img = volume_1[idx].copy()
#       out = gamma_correction(img,g = gamma,c=1.) # img.max())
#       volume_1[idx] = out.copy()


#     # Laplacian of Gaussian フィルタ
#     for idx in range(volume_1.shape[0]):
#       img = volume_1[idx].copy()
#       out = LoG_filter(img,K_size = kernelSize, s = laplace_size,)
#       volume_1[idx] = out.copy()


    fig = get_voxel_slider(volume_1)
    fig.write_image(str(out_dir.joinpath("test_img_slide_1.png")))
    fig.write_html(str(out_dir.joinpath("test_img_slide_1.html")))
    fig.show()


    fig = px.imshow(volume_1[3], color_continuous_scale=px.colors.sequential.Viridis,)
    fig.write_image(str(out_dir.joinpath("test_img_1.png")))
    fig.write_html(str(out_dir.joinpath("test_img_1.html")))
    fig.show()

    z_dim, y_dim, x_dim = volume_1.shape
    pull_num = 2.5 # 2 よりもおおきい数字
    volume_1 = volume_1[:,
                           int(y_dim/2-y_dim/pull_num) : int(y_dim/2+y_dim/pull_num),
                           int(x_dim/2- x_dim/pull_num) : int(x_dim/2 + x_dim/pull_num)
                          ].copy()

    fig = get_voxel_fig(volume_1,
               iso_range_1 ,
               opacity=opacity,
              #  surface_count,
               debug_flag = debug_flag,
               )

    fig.write_image(str(out_dir.joinpath("test_vol_1.png")))
    fig.write_html(str(out_dir.joinpath("test_vol_1.html")))
    fig.show()

    in_dir = Path('/mnt/f/WDDD2/VOXEL/')
    # in_dir_list = [p for p in in_dir.iterdir() if p.is_dir()]
    in_path = in_dir.joinpath("wt_N2_081113_01/wt_N2_081113_01_T50_original.npy")
    base_out_dir = Path('/mnt/f/WDDD2/visualize/')
    out_dir = base_out_dir.joinpath("wt_N2_081113_01/T0/original/")
    out_dir.mkdir(exist_ok=True, parents=True)
    volume = np.load(str(in_path))

    # print(vol.shape) # (66,600,600)
    # volume = vol.T # if (600,600,66)

    volume = resize_volume(volume, size, debug_flag)


    fig = px.imshow(volume[0], color_continuous_scale=px.colors.sequential.Viridis,)
    fig.write_image(str(out_dir.joinpath("test_img.png")))
    fig.write_html(str(out_dir.joinpath("test_img.html")))
    fig.show()


    volume_1 = min_max(volume)  #(0,1)

#     # ガンマ補正
#     for idx in range(volume_1.shape[0]):
#       img = volume_1[idx].copy()
#       out = gamma_correction(img,g = gamma,c=1.) # img.max())
#       volume_1[idx] = out.copy()


#     # Laplacian of Gaussian フィルタ
#     for idx in range(volume_1.shape[0]):
#       img = volume_1[idx].copy()
#       out = LoG_filter(img,K_size = kernelSize, s = laplace_size,)
#       volume_1[idx] = out.copy()


    fig = get_voxel_slider(volume_1)
    fig.write_image(str(out_dir.joinpath("test_img_slide_1.png")))
    fig.write_html(str(out_dir.joinpath("test_img_slide_1.html")))
    fig.show()


    fig = px.imshow(volume_1[3], color_continuous_scale=px.colors.sequential.Viridis,)
    fig.write_image(str(out_dir.joinpath("test_img_1.png")))
    fig.write_html(str(out_dir.joinpath("test_img_1.html")))
    fig.show()

    z_dim, y_dim, x_dim = volume_1.shape
    pull_num = 2.5 # 2 よりもおおきい数字
    volume_1 = volume_1[:,
                           int(y_dim/2-y_dim/pull_num) : int(y_dim/2+y_dim/pull_num),
                           int(x_dim/2- x_dim/pull_num) : int(x_dim/2 + x_dim/pull_num)
                          ].copy()

    fig = get_voxel_fig(volume_1,
               iso_range_1 ,
               opacity=opacity,
              #  surface_count,
               debug_flag = debug_flag,
               )

    fig.write_image(str(out_dir.joinpath("test_vol_1.png")))
    fig.write_html(str(out_dir.joinpath("test_vol_1.html")))
    fig.show()


#     z_dim, y_dim, x_dim = volume.shape
#     axis = 0
#     # pull_num = 3
#     # volume_2 = volume[:,
#     #                        int(y_dim/2-y_dim/pull_num) : int(y_dim/2+y_dim/pull_num),
#     #                        int(x_dim/2- x_dim/pull_num) : int(x_dim/2 + x_dim/pull_num)
#     #                       ].copy()
#     volume_2 = min_max(volume, axis=axis)
#     if debug_flag:
#         print(f"{volume.shape}")
#         print(f"{volume_2.shape}")



# #     for idx in range(volume_1.shape[0]):
# #       img = volume_1[idx].copy()
# #       out = gamma_correction(img,g = gamma,c=1.) # img.max())
# #       volume_1[idx] = out.copy()


# #     for idx in range(volume_1.shape[0]):
# #       img = volume_1[idx].copy()
# #       out = LoG_filter(img,K_size = kernelSize, s = laplace_size,)
# #       volume_1[idx] = out.copy()


#     fig = get_voxel_slider(volume_2)
#     fig.write_image(str(out_dir.joinpath("test_img_slide_2.png")))
#     fig.write_html(str(out_dir.joinpath("test_img_slide_2.html")))
#     fig.show()


#     fig = px.imshow(volume_2[3], color_continuous_scale=px.colors.sequential.Viridis,)
#     fig.write_image(str(out_dir.joinpath("test_img_2.png")))
#     fig.write_html(str(out_dir.joinpath("test_img_2.html")))
#     fig.show()


#     fig = get_voxel_fig(volume_2,
#                iso_range_2 ,
#                opacity=opacity,
#               #  surface_count,
#                 debug_flag = debug_flag,
#                )

#     fig.write_image(str(out_dir.joinpath("test_vol_2.png")))
#     fig.write_html(str(out_dir.joinpath("test_vol_2.html")))
#     fig.show()

if __name__=="__main__":
    main()

